#include "./aie_graph.h"
#include "./config.h"

#define DATA_SIZE (INPUT_BITS/32)
#define N_ITER 1

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fstream>
#include <cstring>
#define AP_INT_MAX_W 16384
#include <ap_int.h>

// This is used for the PL Kernels
#include "xrt/xrt.h"
#include "xrt/experimental/xrt_kernel.h"

// Using the ADF API that call XRT API
#include "adf/adf_api/XRTConfig.h"
simpleGraph addergraph;
static std::vector<char> load_xclbin(xrtDeviceHandle device, const std::string& fnm) {
    if (fnm.empty()) throw std::runtime_error("No xclbin specified");

    std::ifstream stream(fnm);
    stream.seekg(0, stream.end);
    size_t size = stream.tellg();
    stream.seekg(0, stream.beg);

    std::vector<char> header(size);
    stream.read(header.data(), size);

    auto top = reinterpret_cast<const axlf*>(header.data());
    if (xrtDeviceLoadXclbin(device, top)) throw std::runtime_error("Xclbin loading failed");

    return header;
}

template<int N>
ap_uint<N> montpro(ap_uint<N> a, ap_uint<N> b, ap_uint<N> m, ap_uint<N> u){
    ap_uint<N * 2> d = a;
    d *= b;
    ap_uint<N * 2> t = d * u;
    ap_uint<N> c = t(N - 1, 0);
    ap_uint<N * 2> e = c * m;
    ap_uint<N * 2> res = d + e;
    ap_uint<N> result = res(N * 2 - 1, N);
    if(result > m) result = result - m;
    return result;
}

std::string getKey(std::string path){
	std::ifstream ifs;
	ifs.open(path);
	std::string ss = "";
    std::getline(ifs, ss);
	return ss;
}

int main(int argc, char** argv) {

    int en_repeat = 1;
    int de_repeat = 1;
    int enable_vrf = 1;
    bool block_ddr = false;
    uint32_t batch = 1 * 2;
    // int e = 3;

    if(argc == 7){
        batch = atoi(argv[2]);
        en_repeat = atoi(argv[3]);
        de_repeat = atoi(argv[4]);
        enable_vrf = atoi(argv[5]); 
        block_ddr = (atoi(argv[6]) == 1);
        // e = atoi(argv[6]);
    }
    
    // const uint32_t BATCH = batch;
    std::cout << "encryption repeat " << en_repeat << " times" << std::endl;
    std::cout << "decryption repeat " << de_repeat << " times" << std::endl;
    std::cout << "batch " << batch << std::endl;
    // std::cout << "e " << e << std::endl;
    std::cout << "software verify?  " << (enable_vrf == 1 ? "yes" : "no") << std::endl;


    //////////////////////////////////////////
    // Open xclbin
    //////////////////////////////////////////
    auto dhdl = xrtDeviceOpen(0); // Open Device the local device
    if (dhdl == nullptr) throw std::runtime_error("No valid device handle found. Make sure using right xclOpen index.");
    auto xclbin = load_xclbin(dhdl, "krnl_adder.xclbin");
    auto top = reinterpret_cast<const axlf*>(xclbin.data());
    adf::registerXRT(dhdl, top->m_header.uuid);

    const int sizeIn = DATA_SIZE;
    const int sizeOut = DATA_SIZE * 2;

    ap_uint<INPUT_BITS> m("0xCA824817A236C57C4996935C0D5D1F1A7E07D4044A41CF3AE2D0C9233806CBEA5BF33ABCA5ACA7B66A399BF66B65F475A5DE919759DB2C850A9BD1CE1A2D8071BC8DEC7C534E875261070BAF94ECCBC207C9416F03E11D93473F24307C223A068E1342A10F07D4A9F7DD7CF40F1F6BA8F3514D477713DAE25681A2289C1F3D97131C94888338C839BB78DF1F0F24033D0710517DD0A6A16E068E9AA130EBAB855647CBE8DF9F9E69063A8E0607CD04D1FF8E274D48AEC42389282C5379B6F61DF549D282271B227D3090BB698D0D517D98C499683953D6355942F2D3FC68F91B396EBC37E4E986A0463224D51D2462F3B0B9B4C0E478800B3B30497A408A787949D6315B0835F8332605920FC1888A7FF513D0E1F7014D3218C0B159068C54770C1CBA764E6F75E8E119E850A5C6E06C064D08C4E2168B68954FD70FF8AC5AF97E4809219B17CF19DA3F6AF2A04A62C383CAE1A76776180755DA45577CAB0E760196064A7329ED024395FCE41E2A197E161BBD4B8147929891D435AF92826F72A9FE3A3145F2DA54E17F02711302AAA63113610796FB28ADA4CCD1556ED46A13EA2D2E9D473A9F1BC239BC939779E6D9ACF1BA055209DE0FECFD5F503AB799FE78AE2C3CDF6230612357E5A70CAB3CAD39F560D42E5BF29F7D07185B13CDB2CB701CBC8CF2D8FEA4F77AC37682D58CFA12468C370D5E4EA2D96E49E095E9EC1E14119B27890F959D1B629C16F1A595D0ABE528B0E01F68FAC9191A1BF8A89AA10CAE3E5B4401F8F77D6358AFDB6ED47EC95CEB2323416EB4856BDB44F20D9311614055C580C785556A22E5248FEFFB2F599A3D290EE4B2632D2916B870BE8C8FA9C567CCDB7FE0C800032C47C1B180246AD8B6EE455A9A2E5BED2DA80012D16460C6E2F9369D9998C67E21A1566193321E03AC4C6F391332189FEFBD9FC66B0D1A31BD9A7E0A2BF11B8B74A8CEE2D694682F40CAE54593D13CE5C77B14AD530B3DF114318B71630DDE32A8F5BD711AD0EA40C0EE2EDAED0885AE8770F825C3070F5F67457C22F42080B3225A8474D00B03DC88B8E47FD4FC491B59EF6D9A7084BC5B90232BB6DC4DBD4E62AB98D97311000FBDBDB44754FC3AC1D2096C6B8274AC1C050F131F32E87260BFFB9D1863D5AD839B55DBE64905B7EA66D4A84D9A13919CAC2EF47CC0EB07071F51CA89B7BF9AF95BBC146079309F94C9E54D66BEEAB881D9F17C0D8C28049C8E0A06B33E6595671C141E55132C521A27AC6CFC130FE314148E933C355EC1F48BC02943F0A6B6EF4453A68185F7FE13FBEE0E37B205685B1580E0C434A286BB2830D761A5B3FC57266DE3AABC428090F6FBC83402CFB7481B22BA405462A8F972E604809B8F1827DDAF0A3E8642B45F811A55ABFCF66A897EE1BDF87623FFD769C7BBE7A40161CF1193FD7ECB0C0CC9A0664A734D71");
    ap_uint<INPUT_BITS> mp("0x72764BE410C775BE07AF77D2AC0E5B1DF97A9B40A30056596B538A65F3001C857E8253B661D62A27FA7FDA183386BB455B0EAC33B4C5678E6AC03E6147B81C00A5D39A2C35133838428E664CDC2A1259CD94E25716931B5EB3A1AFBF6535C16BFC790C1A623D2C2A09DEAFAA55A606121C27C668069AACD33F2F7DA71C06486946B91484C303CE343758606FDAB195FA2B7B647A5AFD031EE7D95F5077FA808B7D6F8FB7FFE5095B4F090260B4971BE6D6515929534AD9B7F67AEFBB71BBF83DCE3D1B9725F14CABC603B6B30A6E7D712983A25D8E50E25A05CFFA1EA1B468581F2BA1262D82EC9DB9E1AA392EA91B68F988E1FD0CDF4AB6E0AC37EA2D6F8862AEF1965B5C40FA4E97309B16B92015AD6956CFA390AD3BD8AF19BBE679B56F500ED77D4F6F393996FF2F31F43BEBE9858E70F863D67A59506DC6366AFB363B554CE71BC6EABE2D0A4BA2CF5407AECD4EA1AE278CECC00F96A6E746E9D5DAECA802E83C0187357874C128DDDCD131676A9122B4075E5CC10C1FB09FB8BCD38511C55630EB644263C95805749B8C64D16097EB2F6865CC9A407C1E67986B00665F9ACC584CAC1A04DC2CC9FB223DCA004E1131B3144CAFC1FB53E739E028F3C89B2ABD87070374269F2CAFB2A0D8BACA90EF8CD92235E0738D5113450A2D781EAFC1E5D243DE27064A37CB37197F6B8A1B3A2167525A00B8B80689048E7244011EC4A96DF38152B04192AB6324C658D4A77511CF7C86D4F61D27FA6DDDF9862D7A9D1F9F2366D8AA619B3FE7C72526B1F8D75FACC4F8B546BEB8F540A1DB56A49CD3BBC1039886915D6745B34B8CD7F2B74258FF3F43D4FB88C46F27C3BAF287884ECA3BAC876398BC6863AAD01F0FC3870266F019C72394DECEC7349E5DAC4D683C9F97CFC1234D37366E2F31F4CA9895A0B1801EEC5A4D24F2BB4CFC3A402731914C98FEE1FC1F3BA8659E79B6260BB8916F0FD81D84DC0E980FA1EA38FB918DEB436D71413EDCFE1C43141D00F93FE5AF1906774A335F1F990B8B2AB55BE778EF7EF0E7C0A30D9A3C9D85780AB0805884555E7A5E82FED94B3D2A43274EB2EECFEF345D117C62920F8E8A1178466B229D74BA1CF9E494A0BA7F307BF5CEB137AF4E1C650F5C3468F1C97093441DF317ABCA32A01C5347405C4D6D78E3C7434570A0C1829A3224A45067C7C164B6104351263D2BBE71F97B9195CC2A1BA9058EA66DC422DF2F389B02A1AAB67D5708E941297D377BE5D512A34019C25B8C4F8FA92EA488B6D7E66E0C72DE95881AE3AE4936DFB5958BA94F67163491FF52740104F35081D64FAD717B9FF77727A8D78BF88AC74943E94E3F624E6B9252885B8F92483808DE9DFC0B9650EFC243DACD264BE27F5CA3230BB75D5237DA641D5941D4857638228F81F4FF63E4C424DEA0F103D720E7556EDE1A070CEDDA60D22C6F");
    ap_uint<INPUT_BITS> rmod("0x7946CC64332C91D55E96EA223120536BC6F1D2AFCB65F2C0A07A67F3C1ED9B7F644C18DAACAC6103BACA3A849D657F0D0C920CB88880F086450DBE92E5B9723FEE4A048CABE82435EF11B6F74216184EF72F873F7845790689B118B8ED844416531540651B31E3E18840AA8CBB9A09ED9B822B0B210E2C15F9DE36E005AE069CBCBF4AEC93B916807FABD57B9B5DE54179AA0BB90BEEAEE3170BF3F8F4933B48603B7FB1AC33EFA0135B92E626E7FD6DAB4253A7A7A98A8F9BB94A9045A1F6AA60E993A43FCB16EABC4CFFB2D07685C1E5D74C9B7EAE7F731FE29758BAFCC8AF2871B5CB6F18A2B10440BFDD77E71F240C66163046F214E7787640C45E7A56E9CA64F21E5373AD3A2E84AB8F484B7109276995CE492875E07500804A71F28C7081C7F10446A777986A77B358F66F1D0FBE86C43ED44D9865B10A766B06DEAE827BEBF67554D4DC1951F11ECF5F2C4EB756F175B5195944DAC62C54E72EC9B080AD8FFDDD50EE993CD0F1525076AAB0D5A779E685BCB6B91F7E4CB90D9BC9E31939F62AC7690B40D822A7B71842F29FC8B8B1B9BE3B1D09D53341F994CCC1B1C725B84394DEF8CC93441FF8C8DB3DB717673926F8C66968F4252B3D63BCE56DD9853FE6B3C8CF6EC03B0FD348977802A5DFF2F77995DDE67D310C716C09032E829E30D4E8C47D74CDE65FBE1FFCB830C033FF69A06FBA4BEF520FB9F72BE08557061A47ED4BE043990F8E86B41132F1D713922196766F652862E8AE6B60AD7552883FEB8B21F7EAD6E51343E94B68432D3962D3A465D313EF3BC3747225C9DA83F0DD8305925756905B61685C364357AAF9A5A66CA539ADD85B47E52ED6BD6FAE764C9AEF41310D8E3699B2F4A8F3746CA0588D4B0CEFD02CCAB305564B5077FA46FDE62A70F45A2AB002CB0356FC6800216DF61A068E86035F4415D34107420C85F53917CBF9462005523EBA2B256291622838F5E370D479BC47B5DBD897F1F38F16D2D9A37BD30E40F5C4A353627D74138FB3F4211622742A5A894111E9BC5E594945683A81DB6CB4AFA2441C1CD480870ABD88FD303C888C80BCD4509D5C6A4C423F52938D96FE0ADF795C7609E64227F5962DAEF4981DF4A2EF6C8370BABEC36A747921366874393AD5E85DD0781EA4A0775E5CF22155C309511D7BCC6670E83D63DC91388846E32A160D55EB6A465CB70E439B50D23BEDBFE6B55E4021A9D4445D40D025135CA9404778AD94B783B119AEDA6794B00FC8F8599AF436ABAF04C6092254CC78A254B8C3711633508BA5AC560403C914F42456C4B7A3FD1249EE999BE97012E879B3650CB6451DE081AD78855FE2D48C193101B333E7BA8FA3FC59F837E83021D3DB4320D6E57A95BBEDD253CA27231FFAA1F8A18CD76F75175B1DFE15588525121BA3D6CF8062B3F432EB3E194995302DF304198779BD02E6");
    ap_uint<INPUT_BITS> rMod_x_1("0x357DB7E85DC93A83B6696CA3F2A2E0E581F82BFBB5BE30C51D2F36DCC7F93415A40CC5435A53584995C66409949A0B8A5A216E68A624D37AF5642E31E5D27F8E43721383ACB178AD9EF8F4506B13343DF836BE90FC1EE26CB8C0DBCF83DDC5F971ECBD5EF0F82B560822830BF0E094570CAEB2B888EC251DA97E5DD763E0C268ECE36B777CC737C6448720E0F0DBFCC2F8EFAE822F595E91F971655ECF14547AA9B8341720606196F9C571F9F832FB2E0071D8B2B7513BDC76D7D3AC864909E20AB62D7DD8E4DD82CF6F449672F2AE82673B6697C6AC29CAA6BD0D2C039706E4C69143C81B16795FB9CDDB2AE2DB9D0C4F464B3F1B877FF4C4CFB685BF758786B629CEA4F7CA07CCD9FA6DF03E7775800AEC2F1E08FEB2CDE73F4EA6F973AB88F3E34589B1908A171EE617AF5A391F93F9B2F73B1DE974976AB028F00753A50681B7F6DE64E830E625C0950D5FB59D3C7C351E589889E7F8AA25BAA88354F189FE69F9B58CD612FDBC6A031BE1D5E681E9E442B47EB86D676E2BCA506D7D908D5601C5CEBA0D25AB1E80FD8EECFD5559CEEC9EF86904D7525B332EAA912B95EC15D2D162B8C560E43DC6436C68861926530E45FAADF621F01302A0AFC54866018751D3C3209DCF9EDCA81A58F354C352C60A9F2BD1A40D6082F8E7A4EC324D348FE343730D27015B08853C897D2A7305EDB973C8F2A1B15D2691B61F6A1613E1EBEE64D876F06A62E49D63E90E5A6A2F541AD74F1FE0970536E6E5E40757655EF351C1A4BBFE0708829CA75024912B8136A314DCDCBE914B7A9424BB0DF26CEE9EBFAA3A7F387AAA95DD1ADB701004D0A665C2D6F11B4D9CD2D6E9478F417370563A983324801F37FFFCD3B83E4E7FDB95274911BAA565D1A412D257FFED2E9B9F391D06C96266673981DE5EA99E6CCDE1FC53B390C6ECCDE7601042603994F2E5CE426581F5D40EE4748B57311D296B97D0BF351ABA6C2EC31A3884EB52ACF4C20EEBCE748E9CF221CD570A428EE52F15BF3F11D12512F77A51788F07DA3CF8F0A098BA83DD0BDF7F4CDDA57B8B2FF4FC2377471B802B03B6E4A61092658F7B43A46FDCD44923B242B19D5467268CEEFFF042424BB8AB03C53E2DF693947D8B53E3FAF0ECE0CD178D9F400462E79C2A527C64AA2419B6FA4815992B57B265EC6E6353D10B833F14F8F8E0AE357648406506A443EB9F86CF606B361AB2994115477E260E83F273D7FB6371F5F94CC19A6A98E3EBE1AAECD3ADE5D8539303ECF01CEBEB716CC3CAA13E0B743FD6BC0F594910BBAC597E7A0801EC0411F1C84DFA97A4EA7F1F3BCB5D7944D7CF289E5A4C03A8D9921C5543BD7F6F090437CBFD3048B7E4DD45BFAB9D57068D19FB7F6470E7D82250F5C179BD4BA07EE5AA5403099576811E420789DC0028963844185BFE9E30EE6C028134F3F3365F99B58CB28F");
    ap_uint<INPUT_BITS> pub_e("0x10001");
    ap_uint<INPUT_BITS> prv_e("0x8221CA35F5B5809E67A36D3A60141122B30E50BE1901C52B3009BED6F4EFD925D6C4AC60018EBB8F4B1F8E0B81E4587D2983A6C73DA4CC2D0A2E2B5A681409500D3C9E551E2B7E65FF97C978A118B1AF13D5CE488A93A4AFB9BEE78088A46DE93C6F4007C362E2D3FE45C440095FC58D221E82AC83E6AC6779F37FC2DCE06E71A08463267E3C84DE248C7DC4B5B40CA8B0DB59A2A1EC121C63F64B837DAE53E0311B9DFB1D88B3010651A66655A8F78A02D0D48CA3423B2422C54006BC56483DE41BF63C50E8ECF6C9B897D6321FF6D7E0CDA54F0657CB7528D10EBE0E9B5E4892558879DA8DFE470C14B8FA81E999F4C301F3176939CDFE69A093F70D766E0872DC43871DF5A0732DE1B28491772E991F62067ECE7D759FD5AC2DCAE99C4FC2D873B596C4BC776699104EEB543C4286E85DA45EF072504F7A737DDDF38CBE414956FD172D54D56EE5828F352EAFDE5B895B5C3A790FB84D2E6C3ED70373E0AD1043D9F309A24D7D80F4E737A7F2A1C3166DE8EC963CEA0544E0BB4701BCF3E5193C172506B012812D0EB300FA986214BDC0983F8A540745DE7B07A200C05B12450F97BED5C0E3F1B093ED8C6270A15A0BFAA1F13D50BDF439F46FC55C96134D253BB78DBE76986433940E2D94C48D0F3C096499B4D8BD46A3CF6565518A83749BACBBB54F7105E1F86E5920D4DE69E360CF18D75FADD4966D66A3EEC0273BE4CAF463A746608BE3CCDF0FFB85107598E85DCDE735E80E119CD00B1A274304255E4A01CFFCADE109732A2914408FE91FE9945933AA6160015C91D8F1FFA8DD534BFB27AAD6EA5C9E0395BA36C05AC99B8C0A203A66D263DDA9183BE0938720E7C1D6DB60B9A02DC2F1A7459AE4594924416BB573FC9BFBE1DE2E18A95BB2EBB2BDA3C468456A45D3E983953C0269631B9F3188DC3AC21A33741C24F976FBFDB568F8C40C78B9A20D0A38462825DF3D54585CB31D3DEE786E1BB53EA7680E9BF45625897C31EF56EDF8709E2A4C091B7364119E862816FD35E5C8196016CB02B0135933998A7B0D846F3B62137786E5169453403BE1EF3F4F726E5E9622704BE7C963B13F96F3A3F1376AF1728A108691891510BF84DA8B8A7A5CBB67F30677AEFC1FBBB233813CF9104AAC940437757EA1B5EFE9CFBE957C4B4625F5A07AB0E6642F42535B94E6BAB4BEA3AE5946E1172C20A3987D800E0FBA9B511E4101AB47E473675069A4949E702F4F51D28A5737CD25DC6A7CC98DFEAE8EB24DD9ED3F6A6E9213A9B464B592FD0C5DD766C39EE180BF9F1ECCCB3D6F265D6C41A0FE5A305CD229BBAE04B9DEB8B24AF02A7BBD877476FE4AF502805E3006E85F2E0D70B0CB1F09A6510FC99D31983A5AC2A7A527C1FBD6DE2315C4CA6B33BDE90A39DADA7D7C9ADDA950124F17346473C3F99A2337E1CD3F79CAB3974EFC53A6C4FE4549");

    uint32_t * buf_n = (uint32_t *) malloc(INPUT_BITS / 8);
    uint32_t * buf_pub_e = (uint32_t *) malloc(INPUT_BITS / 8);
    uint32_t * buf_prv_e = (uint32_t *) malloc(INPUT_BITS / 8);
    uint32_t * buf_nInv = (uint32_t *) malloc(INPUT_BITS / 8);
    uint32_t * buf_rMod = (uint32_t *) malloc(INPUT_BITS / 8);
    uint32_t * buf_rMod_x_1 = (uint32_t *) malloc(INPUT_BITS / 8);

    for(int i = 0; i < INPUT_BITS / 32; ++i){
        buf_n[i] = m((i + 1) * 32 - 1, i * 32);
        buf_pub_e[i] = pub_e((i + 1) * 32 - 1, i * 32);
        buf_prv_e[i] = prv_e((i + 1) * 32 - 1, i * 32);
        buf_nInv[i] = mp((i + 1) * 32 - 1, i * 32);
        buf_rMod[i] = rmod((i + 1) * 32 - 1, i * 32);
        buf_rMod_x_1[i] = rMod_x_1((i + 1) * 32 - 1, i * 32);
    }
    srand(time(0));

    uint32_t *data_in_0 = (uint32_t *) malloc(batch * INPUT_BITS / 8);
    uint32_t *cypher_0 = (uint32_t *) malloc(batch * INPUT_BITS / 8);
for(int i = 0; i < batch; ++i){
        ap_uint<INPUT_BITS> tmp;

        for(int j = 0; j < INPUT_BITS / 32; ++j){
            tmp((j + 1) * 32 - 1, j * 32) = rand();
        }
        tmp %= m;
        for(int j = 0; j < INPUT_BITS / 32; ++j){
            data_in_0[i * INPUT_BITS / 32 + j] = tmp((j + 1) * 32 - 1, j * 32);
        }
}

    


    xrtBufferHandle data_in_hdl_0 = xrtBOAlloc(dhdl, batch * INPUT_BITS / 8, 0, 0);
    auto data_in_mapped_0 = reinterpret_cast<uint32_t*>(xrtBOMap(data_in_hdl_0));
    memcpy(data_in_mapped_0, data_in_0, batch * INPUT_BITS / 8);

    xrtBufferHandle exp_hdl_0 = xrtBOAlloc(dhdl, INPUT_BITS / 8, 0, 0);
    auto exp_mapped_0 = reinterpret_cast<uint32_t*>(xrtBOMap(exp_hdl_0));
    memcpy(exp_mapped_0, buf_pub_e, INPUT_BITS / 8);

    xrtBufferHandle n_hdl_0 = xrtBOAlloc(dhdl, INPUT_BITS / 8, 0, 0);
    auto n_mapped_0 = reinterpret_cast<uint32_t*>(xrtBOMap(n_hdl_0));
    memcpy(n_mapped_0, buf_n, INPUT_BITS / 8);

    xrtBufferHandle nInv_hdl_0 = xrtBOAlloc(dhdl, INPUT_BITS / 8, 0, 0);
    auto nInv_mapped_0 = reinterpret_cast<uint32_t*>(xrtBOMap(nInv_hdl_0));
    memcpy(nInv_mapped_0, buf_nInv, INPUT_BITS / 8);

    xrtBufferHandle rMod_hdl_0 = xrtBOAlloc(dhdl, INPUT_BITS / 8, 0, 0);
    auto rMod_mapped_0 = reinterpret_cast<uint32_t*>(xrtBOMap(rMod_hdl_0));
    memcpy(rMod_mapped_0, buf_rMod, INPUT_BITS / 8);

    xrtBufferHandle rMod_x_1_hdl_0 = xrtBOAlloc(dhdl, INPUT_BITS / 8, 0, 0);
    auto rMod_x_1_mapped_0 = reinterpret_cast<uint32_t*>(xrtBOMap(rMod_x_1_hdl_0));
    memcpy(rMod_x_1_mapped_0, buf_rMod_x_1, INPUT_BITS / 8);

    xrtBufferHandle data_out_hdl_0 = xrtBOAlloc(dhdl, batch * INPUT_BITS / 8, 0, 0);
    auto data_out_mapped_0 = reinterpret_cast<uint32_t*>(xrtBOMap(data_out_hdl_0));
    memset(data_out_mapped_0, 0xABCDEF00, batch * INPUT_BITS / 8);



    printf("graph init. This does nothing because CDO in boot PDI already configures AIE.\n");
    addergraph.init();

    printf("graph run\n");
    addergraph.run(-1);


    double kernel_time_in_sec = 0;
    std::chrono::duration<double> kernel_time(0);
    auto kernel_start = std::chrono::high_resolution_clock::now();

    xrtKernelHandle pl_kernel_khdl1_0 = xrtPLKernelOpen(dhdl, top->m_header.uuid, "pl_kernel:{pl_kernel_0}");

    xrtRunHandle pl_kernel_rhdl1_0 = xrtKernelRun(pl_kernel_khdl1_0, data_in_hdl_0, data_out_hdl_0, exp_hdl_0, n_hdl_0, nInv_hdl_0, rMod_hdl_0, rMod_x_1_hdl_0, 20, batch, en_repeat, block_ddr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr);

    auto state_0 = xrtRunWait(pl_kernel_rhdl1_0);

    for(uint32_t i = 0; i < batch * INPUT_BITS / 32; ++i){
        cypher_0[i] = data_out_mapped_0[i];
    }
auto kernel_end = std::chrono::high_resolution_clock::now();
    kernel_time = std::chrono::duration<double>(kernel_end - kernel_start);
    kernel_time_in_sec = kernel_time.count();
    std::cout << "encryption repeat: " << en_repeat << std::endl;
    std::cout << "encryption time: " << kernel_time_in_sec << " sec" << std::endl;


    xrtRunClose(pl_kernel_rhdl1_0);
    xrtKernelClose(pl_kernel_khdl1_0);



    xrtBufferHandle decrypt_data_in_hdl_0 = xrtBOAlloc(dhdl, batch * INPUT_BITS / 8, 0, 0);
    auto decrypt_data_in_mapped_0 = reinterpret_cast<uint32_t*>(xrtBOMap(decrypt_data_in_hdl_0));
    memcpy(decrypt_data_in_mapped_0, cypher_0, batch * INPUT_BITS / 8);

    xrtBufferHandle decrypt_exp_hdl_0 = xrtBOAlloc(dhdl, INPUT_BITS / 8, 0, 0);
    auto decrypt_exp_mapped_0 = reinterpret_cast<uint32_t*>(xrtBOMap(decrypt_exp_hdl_0));
    memcpy(decrypt_exp_mapped_0, buf_prv_e, INPUT_BITS / 8);

    xrtBufferHandle decrypt_n_hdl_0 = xrtBOAlloc(dhdl, INPUT_BITS / 8, 0, 0);
    auto decrypt_n_mapped_0 = reinterpret_cast<uint32_t*>(xrtBOMap(decrypt_n_hdl_0));
    memcpy(decrypt_n_mapped_0, buf_n, INPUT_BITS / 8);

    xrtBufferHandle decrypt_nInv_hdl_0 = xrtBOAlloc(dhdl, INPUT_BITS / 8, 0, 0);
    auto decrypt_nInv_mapped_0 = reinterpret_cast<uint32_t*>(xrtBOMap(decrypt_nInv_hdl_0));
    memcpy(decrypt_nInv_mapped_0, buf_nInv, INPUT_BITS / 8);

    xrtBufferHandle decrypt_rMod_hdl_0 = xrtBOAlloc(dhdl, INPUT_BITS / 8, 0, 0);
    auto decrypt_rMod_mapped_0 = reinterpret_cast<uint32_t*>(xrtBOMap(decrypt_rMod_hdl_0));
    memcpy(decrypt_rMod_mapped_0, buf_rMod, INPUT_BITS / 8);

    xrtBufferHandle decrypt_rMod_x_1_hdl_0 = xrtBOAlloc(dhdl, INPUT_BITS / 8, 0, 0);
    auto decrypt_rMod_x_1_mapped_0 = reinterpret_cast<uint32_t*>(xrtBOMap(decrypt_rMod_x_1_hdl_0));
    memcpy(decrypt_rMod_x_1_mapped_0, buf_rMod_x_1, INPUT_BITS / 8);

    xrtBufferHandle decrypt_data_out_hdl_0 = xrtBOAlloc(dhdl, batch * INPUT_BITS / 8, 0, 0);
    auto decrypt_data_out_mapped_0 = reinterpret_cast<uint32_t*>(xrtBOMap(decrypt_data_out_hdl_0));
    memset(decrypt_data_out_mapped_0, 0xABCDEF00, batch * INPUT_BITS / 8);
kernel_start = std::chrono::high_resolution_clock::now();
  
    xrtKernelHandle pl_kernel_khdl2_0 = xrtPLKernelOpen(dhdl, top->m_header.uuid, "pl_kernel:{pl_kernel_0}");
  
    xrtRunHandle pl_kernel_rhdl2_0 = xrtKernelRun(pl_kernel_khdl2_0, decrypt_data_in_hdl_0, decrypt_data_out_hdl_0, decrypt_exp_hdl_0, decrypt_n_hdl_0, decrypt_nInv_hdl_0, decrypt_rMod_hdl_0, decrypt_rMod_x_1_hdl_0, INPUT_BITS, batch, de_repeat, block_ddr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr);
  
    auto state2_0 = xrtRunWait(pl_kernel_rhdl2_0);
kernel_end = std::chrono::high_resolution_clock::now();
    kernel_time = std::chrono::duration<double>(kernel_end - kernel_start);
    kernel_time_in_sec = kernel_time.count();
    std::cout << "decryption repeat: " << de_repeat << std::endl;
    std::cout << "decryption time: " << kernel_time_in_sec << " sec" << std::endl;


    int errorCount = 0;
    if(enable_vrf == 1)
    {
  
        for(int i = 0; i < batch * INPUT_BITS / 32; ++i){
            if(decrypt_data_out_mapped_0[i] != data_in_0[i]){
                errorCount++;
                std::cout << "plaintext[" << i << "]: " << data_in_0[i] << " != " << "decryption[" << i << "]: " << decrypt_data_out_mapped_0[i] << std::endl;
            }
        }
if (errorCount)
            printf("Test(%d) failed with %d errors\n", 1 * batch * INPUT_BITS / 32, errorCount);
        else
            printf("TEST PASSED!!\n");
    }

  
    xrtBOFree(data_in_hdl_0);
    xrtBOFree(exp_hdl_0);
    xrtBOFree(n_hdl_0);
    xrtBOFree(nInv_hdl_0);
    xrtBOFree(rMod_hdl_0);
    xrtBOFree(rMod_x_1_hdl_0);
    xrtBOFree(data_out_hdl_0);

    xrtBOFree(decrypt_data_in_hdl_0);
    xrtBOFree(decrypt_exp_hdl_0);
    xrtBOFree(decrypt_n_hdl_0);
    xrtBOFree(decrypt_nInv_hdl_0);
    xrtBOFree(decrypt_rMod_hdl_0);
    xrtBOFree(decrypt_rMod_x_1_hdl_0);
    xrtBOFree(decrypt_data_out_hdl_0);
    free(data_in_0);
    free(cypher_0);
free(buf_n);
    free(buf_pub_e);
    free(buf_prv_e);
    free(buf_nInv);
    free(buf_rMod);
    free(buf_rMod_x_1);

    xrtDeviceClose(dhdl);
    return 0;

}